"use strict";(self.webpackChunkatmo_trial_doc=self.webpackChunkatmo_trial_doc||[]).push([[2262],{3905:function(e,t,n){n.d(t,{Zo:function(){return c},kt:function(){return m}});var r=n(7294);function a(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function i(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);t&&(r=r.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,r)}return n}function s(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?i(Object(n),!0).forEach((function(t){a(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):i(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function o(e,t){if(null==e)return{};var n,r,a=function(e,t){if(null==e)return{};var n,r,a={},i=Object.keys(e);for(r=0;r<i.length;r++)n=i[r],t.indexOf(n)>=0||(a[n]=e[n]);return a}(e,t);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(e);for(r=0;r<i.length;r++)n=i[r],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(a[n]=e[n])}return a}var u=r.createContext({}),l=function(e){var t=r.useContext(u),n=t;return e&&(n="function"==typeof e?e(t):s(s({},t),e)),n},c=function(e){var t=l(e.components);return r.createElement(u.Provider,{value:t},e.children)},d={inlineCode:"code",wrapper:function(e){var t=e.children;return r.createElement(r.Fragment,{},t)}},p=r.forwardRef((function(e,t){var n=e.components,a=e.mdxType,i=e.originalType,u=e.parentName,c=o(e,["components","mdxType","originalType","parentName"]),p=l(n),m=a,y=p["".concat(u,".").concat(m)]||p[m]||d[m]||i;return n?r.createElement(y,s(s({ref:t},c),{},{components:n})):r.createElement(y,s({ref:t},c))}));function m(e,t){var n=arguments,a=t&&t.mdxType;if("string"==typeof e||a){var i=n.length,s=new Array(i);s[0]=p;var o={};for(var u in t)hasOwnProperty.call(t,u)&&(o[u]=t[u]);o.originalType=e,o.mdxType="string"==typeof e?e:a,s[1]=o;for(var l=2;l<i;l++)s[l]=n[l];return r.createElement.apply(null,s)}return r.createElement.apply(null,n)}p.displayName="MDXCreateElement"},9381:function(e,t,n){n.r(t),n.d(t,{frontMatter:function(){return o},contentTitle:function(){return u},metadata:function(){return l},toc:function(){return c},default:function(){return p}});var r=n(7462),a=n(3366),i=(n(7294),n(3905)),s=["components"],o={},u="Using SQL databases",l={unversionedId:"atmo/usage/using-sql-databases",id:"atmo/usage/using-sql-databases",isDocsHomePage:!1,title:"Using SQL databases",description:"To connect Atmo with your SQL database, you will define the connection using the connections section of the Directive, and then define queries that your Runnables can execute. Runnables are not allowed to execute arbitrary queries. Instead, a list of named queries are provided in a Queries.yaml file, and then your Runnables are allowed to execute them.",source:"@site/docs/atmo/usage/using-sql-databases.md",sourceDirName:"atmo/usage",slug:"/atmo/usage/using-sql-databases",permalink:"/docs/docs/atmo/usage/using-sql-databases",editUrl:"https://github.com/suborbital/docs/edit/master/atmo-trial-docs/docs/atmo/usage/using-sql-databases.md",tags:[],version:"current",lastUpdatedAt:1638971475,formattedLastUpdatedAt:"12/8/2021",frontMatter:{},sidebar:"docs",previous:{title:"Streams",permalink:"/docs/docs/atmo/usage/streams"}},c=[{value:"Defining queries",id:"defining-queries",children:[],level:2},{value:"Query variables",id:"query-variables",children:[],level:2},{value:"How it works",id:"how-it-works",children:[],level:2},{value:"Executing queries",id:"executing-queries",children:[],level:2}],d={toc:c};function p(e){var t=e.components,n=(0,a.Z)(e,s);return(0,i.kt)("wrapper",(0,r.Z)({},d,n,{components:t,mdxType:"MDXLayout"}),(0,i.kt)("h1",{id:"using-sql-databases"},"Using SQL databases"),(0,i.kt)("p",null,"To connect Atmo with your SQL database, you will define the connection using the ",(0,i.kt)("inlineCode",{parentName:"p"},"connections")," section of the Directive, and then define queries that your Runnables can execute. Runnables are not allowed to execute arbitrary queries. Instead, a list of named queries are provided in a Queries.yaml file, and then your Runnables are allowed to execute them."),(0,i.kt)("p",null,"If you haven't already, take a look at Connections to define the connection to your database, then come back here."),(0,i.kt)("p",null,"{% hint style=\"info\" %}\nAtmo's Database capability is in preview, and we would love your feedback on the approach as well as the Rust APIs. We are eager to improve it, and we hope you'll try it out! Please join our Discord to give us feedback.\n{% endhint %}"),(0,i.kt)("h2",{id:"defining-queries"},"Defining queries"),(0,i.kt)("p",null,"Once the connection to your database is defined, create a ",(0,i.kt)("inlineCode",{parentName:"p"},"Queries.yaml")," file in your project's directory, right next to ",(0,i.kt)("inlineCode",{parentName:"p"},"Directive.yaml"),". It will have this structure:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-yaml"},'queries:\n  - name: "InsertUser"\n    query: |-\n      INSERT INTO users (uuid, email, created_at, state, identifier)\n      VALUES ($1, $2, NOW(), \'A\', 12345)\n\n  - name: "SelectUserWithUUID"\n    query: |-\n      SELECT * FROM users\n      WHERE uuid = $1\n  \n  - name: "UpdateUserWithUUID"\n    query: |-\n      UPDATE users SET state=\'B\' \n      WHERE uuid = $1\n')),(0,i.kt)("p",null,"You can define any number of queries. Each query must have a name and a query value."),(0,i.kt)("p",null,"Queries can optionally have a ",(0,i.kt)("inlineCode",{parentName:"p"},"type")," field (specifying ",(0,i.kt)("inlineCode",{parentName:"p"},"select | update | insert | delete"),") and a ",(0,i.kt)("inlineCode",{parentName:"p"},"varCount")," field to specify the number of variables in the query. In most circumstances, these optional fields are detected automatically by Atmo, but if for any reason they are detected incorrectly, you can set them explicitly."),(0,i.kt)("h2",{id:"query-variables"},"Query variables"),(0,i.kt)("p",null,"Queries can contain variables in either the MySQL style ",(0,i.kt)("inlineCode",{parentName:"p"},"?")," or in the PostgreSQL style ",(0,i.kt)("inlineCode",{parentName:"p"},"$1"),". Both will be auto-detected by Atmo, and Runnables will be required to provide the correct number of arguments to fill those variables whenever a query is called."),(0,i.kt)("h2",{id:"how-it-works"},"How it works"),(0,i.kt)("p",null,"SQL queries in Atmo are automatically turned into prepared statements that ensure your queries are executed safely. Atmo uses industry-standard database drivers to maintain a connection pool with your database. Runnables are allowed to execute the defined queries and provide the arguments to be inserted into those queries. Your code does not need to concern itself with the underlying database connections, pooling, credentials, etc. You can focus on building your business logic."),(0,i.kt)("h2",{id:"executing-queries"},"Executing queries"),(0,i.kt)("p",null,"Once you've defined queries in your Queries.yaml file, the ",(0,i.kt)("inlineCode",{parentName:"p"},"suborbital")," Rust crate has APIs for executing various query types:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-rust"},'use suborbital::runnable::*;\nuse suborbital::db;\nuse suborbital::db::query;\nuse suborbital::log;\nuse uuid::Uuid;\n\nstruct CreateUser{}\n\nimpl Runnable for CreateUser {\n    fn run(&self, _: Vec<u8>) -> Result<Vec<u8>, RunErr> {\n        let uuid = Uuid::new_v4().to_string();\n\n        let mut args: Vec<query::QueryArg> = Vec::new();\n        args.push(query::QueryArg::new("uuid", uuid.as_str()));\n        args.push(query::QueryArg::new("email", "connor@suborbital.dev"));\n\n        match db::insert("InsertUser", args) {\n            Ok(_) => log::info("insert successful"),\n            Err(e) => {\n                return Err(RunErr::new(500, e.message.as_str()))\n            }\n        };\n        \n        let mut args2: Vec<query::QueryArg> = Vec::new();\n        args2.push(query::QueryArg::new("uuid", uuid.as_str()));\n\n        match db::update("UpdateUserWithUUID", args2.clone()) {\n            Ok(_) => log::info("update successful"),\n            Err(e) => {\n                return Err(RunErr::new(500, e.message.as_str()))\n            }\n        };\n\n        match db::select("SelectUserWithUUID", args2) {\n            Ok(result) => Ok(result),\n            Err(e) => {\n                Err(RunErr::new(500, e.message.as_str()))\n            }\n        }\n    }\n}\n\n// initialize the runner, do not edit below //\nstatic RUNNABLE: &CreateUser = &CreateUser{};\n\n#[no_mangle]\npub extern fn _start() {\n    use_runnable(RUNNABLE);\n}\n\n')),(0,i.kt)("p",null,"Runnables can execute any of the queries defined in ",(0,i.kt)("inlineCode",{parentName:"p"},"Queries.yaml"),". The ",(0,i.kt)("inlineCode",{parentName:"p"},"args")," they provide are inserted into the queries' variables by Atmo, and then executed. The query's results are returned to the Runnable in JSON form."))}p.isMDXComponent=!0}}]);